{"version":3,"sources":["webpack:///./pkg/photon.js"],"names":["passStringToWasm","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","cachegetUint8Memory","getUint8Memory","buffer","wasm","Uint8Array","draw_text_with_border","photon_img","text","x","y","ptr0","ptr","ptr1","len1","PhotonImage","__wrap","draw_text","lch","photon_image","mode","amt","hsl","hsv","hue_rotate_hsl","img","degrees","hue_rotate_hsv","hue_rotate_lch","saturate_hsl","level","saturate_lch","saturate_hsv","lighten_lch","lighten_hsl","lighten_hsv","darken_lch","darken_hsl","darken_hsv","noise_reduction","sharpen","edge_detection","identity","box_blur","gaussian_blur","detect_horizontal_lines","detect_vertical_lines","detect_45_deg_lines","detect_135_deg_lines","laplace","edge_one","emboss","sobel_horizontal","prewitt_horizontal","sobel_vertical","add_noise_rand","pink_noise","watermark","blend","photon_image2","blend_mode","ptr2","len2","encodeInto","arg","size","length","offset","mem","code","charCodeAt","slice","view","subarray","written","buf","encode","set","heap","Array","fill","undefined","push","heap_next","addHeapObject","obj","idx","run","stack_pointer","addBorrowedObject","Error","getObject","dropObject","takeObject","ret","getImageData","canvas","ctx","putImageData","new_image","open_image","new_rgb","imgdata","r","g","b","Rgb","getArrayU8FromWasm","len","cachedGlobalArgumentPtr","globalArgumentPtr","cachegetUint32Memory","getUint32Memory","Uint32Array","to_raw_pixels","retptr","rustptr","rustlen","realRet","to_image_data","channel_index","offset_red","offset_amt","offset_green","offset_blue","multiple_offsets","channel_index2","duotone","color_a","color_b","primary","colorize","solarize","inc_brightness","brightness","tint","r_offset","g_offset","b_offset","alter_channel","channel","alter_red_channel","alter_green_channel","alter_blue_channel","alter_two_channels","channel1","offset1","channel2","offset2","alter_channels","remove_channel","min_filter","remove_red_channel","remove_green_channel","remove_blue_channel","swap_channels","selective_hue_rotate","ref_color","selective_lighten","selective_desaturate","selective_saturate","selective_greyscale","filter","filter_name","neue","lix","ryo","base64_to_image","base64","len0","monochrome","sepia","grayscale","grayscale_human_corrected","desaturate","decompose_min","decompose_max","grayscale_shades","num_shades","r_grayscale","g_grayscale","b_grayscale","single_channel_grayscale","threshold","cachedTextDecoder","TextDecoder","getStringFromWasm","decode","__wbg_error_4bb6c2a97407129a","arg0","arg1","varg0","console","error","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","stack","retlen","handleError","exnptr","e","__widl_f_get_image_data_CanvasRenderingContext2D","arg2","arg3","arg4","__widl_f_put_image_data_CanvasRenderingContext2D","__widl_f_create_element_Document","varg1","createElement","isLikeNone","__widl_f_body_Document","val","body","__widl_f_width_HTMLCanvasElement","width","__widl_f_height_HTMLCanvasElement","height","cachegetUint8ClampedMemory","getClampedArrayU8FromWasm","Uint8ClampedArray","__widl_f_new_with_u8_clamped_array_and_sh_ImageData","ImageData","__widl_f_data_ImageData","data","__widl_f_append_child_Node","appendChild","__widl_f_set_text_content_Node","textContent","__widl_instanceof_Window","Window","__widl_f_document_Window","document","__wbg_newnoargs_a172f39151049128","Function","__wbg_call_8a9c8b0a32a202ff","call","__wbindgen_debug_string","i","len_ptr","toString","Object","prototype","debug","debug_str","type","_typeof","concat","description","name","isArray","className","builtInMatches","exec","JSON","stringify","_","message","__wbindgen_rethrow","__wbindgen_throw","_classCallCheck","this","_createClass","key","value","freePhotonImage","img_data","create","freeRgb","get","__wbindgen_object_clone_ref","__wbindgen_object_drop_ref"],"mappings":"q1LAEA,IAYIA,EAZAC,EAAkB,EAElBC,EAAoB,IAAIC,YAAY,SAEpCC,EAAsB,KAC1B,SAASC,IAIL,OAH4B,OAAxBD,GAAgCA,EAAoBE,SAAWC,KAAYD,SAC3EF,EAAsB,IAAII,WAAWD,KAAYD,SAE9CF,EAiEJ,SAASK,EAAsBC,EAAYC,EAAMC,EAAGC,GACvD,IAAMC,EAAOJ,EAAWK,IACxBL,EAAWK,IAAM,EACjB,IAAMC,EAAOhB,EAAiBW,GACxBM,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAA2BO,EAAME,EAAMC,EAAML,EAAGC,IAD9E,QAIIN,IAAqBS,EAAa,EAAPC,IAc5B,SAASG,EAAUV,EAAYC,EAAMC,EAAGC,GAC3C,IAAMC,EAAOJ,EAAWK,IACxBL,EAAWK,IAAM,EACjB,IAAMC,EAAOhB,EAAiBW,GACxBM,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAAeO,EAAME,EAAMC,EAAML,EAAGC,IADlE,QAIIN,IAAqBS,EAAa,EAAPC,IAa5B,SAASI,EAAIC,EAAcC,EAAMC,GACpC,IAAMV,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOhB,EAAiBuB,GACxBN,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,KAASO,EAAME,EAAMC,EAAMO,IADzD,QAIIjB,IAAqBS,EAAa,EAAPC,IAa5B,SAASQ,EAAIH,EAAcC,EAAMC,GACpC,IAAMV,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOhB,EAAiBuB,GACxBN,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAASO,EAAME,EAAMC,EAAMO,IADzD,QAIIjB,IAAqBS,EAAa,EAAPC,IAa5B,SAASS,EAAIJ,EAAcC,EAAMC,GACpC,IAAMV,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOhB,EAAiBuB,GACxBN,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAASO,EAAME,EAAMC,EAAMO,IADzD,QAIIjB,IAAqBS,EAAa,EAAPC,IAY5B,SAASU,EAAeC,EAAKC,GAChC,IAAMf,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAoBO,EAAMe,IASjD,SAASC,EAAeF,EAAKC,GAChC,IAAMf,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAoBO,EAAMe,IASjD,SAASE,EAAeH,EAAKC,GAChC,IAAMf,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAoBO,EAAMe,IAUjD,SAASG,EAAaJ,EAAKK,GAC9B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAkBO,EAAMmB,IAS/C,SAASC,EAAaN,EAAKK,GAC9B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAkBO,EAAMmB,IAS/C,SAASE,EAAaP,EAAKK,GAC9B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAkBO,EAAMmB,IAS/C,SAASG,EAAYR,EAAKK,GAC7B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAiBO,EAAMmB,IAS9C,SAASI,EAAYT,EAAKK,GAC7B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAiBO,EAAMmB,IAS9C,SAASK,EAAYV,EAAKK,GAC7B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAiBO,EAAMmB,IAS9C,SAASM,EAAWX,EAAKK,GAC5B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAgBO,EAAMmB,IAS7C,SAASO,EAAWZ,EAAKK,GAC5B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAgBO,EAAMmB,IAS7C,SAASQ,EAAWb,EAAKK,GAC5B,IAAMnB,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAgBO,EAAMmB,IAoB7C,SAASS,EAAgBpB,GAC5B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAqBO,IAoB5C,SAAS6B,EAAQrB,GACpB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAaO,IAmBpC,SAAS8B,EAAetB,GAC3B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAoBO,IAmB3C,SAAS+B,EAASvB,GACrB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAcO,IAmBrC,SAASgC,EAASxB,GACrB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAcO,IAmBrC,SAASiC,EAAczB,GAC1B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAmBO,IAmB1C,SAASkC,EAAwB1B,GACpC,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAA6BO,IAmBpD,SAASmC,EAAsB3B,GAClC,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAA2BO,IAmBlD,SAASoC,EAAoB5B,GAChC,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAyBO,IAmBhD,SAASqC,EAAqB7B,GACjC,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAA0BO,IAmBjD,SAASsC,EAAQ9B,GACpB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAaO,IAmBpC,SAASuC,EAAS/B,GACrB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAcO,IAmBrC,SAASwC,EAAOhC,GACnB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAYO,IAmBnC,SAASyC,EAAiBjC,GAC7B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAsBO,IAmB7C,SAAS0C,EAAmBlC,GAC/B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAwBO,IAmB/C,SAAS2C,EAAenC,GAC3B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAoBO,IAqB3C,SAAS4C,EAAepC,GAC3B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAoBO,IAmB3C,SAAS6C,EAAWrC,GACvB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAgBO,IAwBvC,SAAS8C,EAAUhC,EAAKgC,EAAWhD,EAAGC,GACzC,IAAMC,EAAOc,EAAIb,IACjBa,EAAIb,IAAM,EACV,IAAMC,EAAO4C,EAAU7C,IAEvB,OADA6C,EAAU7C,IAAM,EACTG,GAAYC,OAAOZ,KAAeO,EAAME,EAAMJ,EAAGC,IA0CrD,SAASgD,EAAMvC,EAAcwC,EAAeC,GAC/C,IAAMjD,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAO8C,EAAc/C,IAC3B+C,EAAc/C,IAAM,EACpB,IAAMiD,EAAOhE,EAAiB+D,GACxBE,EAAOhE,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAAWO,EAAME,EAAMgD,EAAMC,IAD3D,QAII1D,IAAqByD,EAAa,EAAPC,IApxB/BjE,EADwC,mBAAjCE,EAAkBgE,WACN,SAASC,GAQpB,IALJ,IAAIC,EAAOD,EAAIE,OACXtD,EAAMR,IAAuB6D,GAC7BE,EAAS,EAEHC,EAAMlE,IACLiE,EAASH,EAAIE,OAAQC,IAAU,CAClC,IAAME,EAAOL,EAAIM,WAAWH,GAC5B,GAAIE,EAAO,IAAM,MACjBD,EAAIxD,EAAMuD,GAAUE,EAI5B,GAAIF,IAAWH,EAAIE,OAAQ,CACvBF,EAAMA,EAAIO,MAAMJ,GAChBvD,EAAMR,IAAwBQ,EAAKqD,EAAMA,EAAOE,EAAsB,EAAbH,EAAIE,QAC7D,IAAMM,EAAOtE,IAAiBuE,SAAS7D,EAAMuD,EAAQvD,EAAMqD,GAG3DE,GAFYpE,EAAkBgE,WAAWC,EAAKQ,GAEhCE,QAGlB,OADA5E,EAAkBqE,EACXvD,GAGQ,SAASoD,GAQpB,IALJ,IAAIC,EAAOD,EAAIE,OACXtD,EAAMR,IAAuB6D,GAC7BE,EAAS,EAEHC,EAAMlE,IACLiE,EAASH,EAAIE,OAAQC,IAAU,CAClC,IAAME,EAAOL,EAAIM,WAAWH,GAC5B,GAAIE,EAAO,IAAM,MACjBD,EAAIxD,EAAMuD,GAAUE,EAI5B,GAAIF,IAAWH,EAAIE,OAAQ,CACvB,IAAMS,EAAM5E,EAAkB6E,OAAOZ,EAAIO,MAAMJ,IAC/CvD,EAAMR,IAAwBQ,EAAKqD,EAAMA,EAAOE,EAASQ,EAAIT,QAC7DhE,IAAiB2E,IAAIF,EAAK/D,EAAMuD,GAChCA,GAAUQ,EAAIT,OAGlB,OADApE,EAAkBqE,EACXvD,GAyuBf,IAAMkE,EAAO,IAAIC,MAAM,IAEvBD,EAAKE,UAAKC,GAEVH,EAAKI,UAAKD,EAAW,MAAM,GAAM,GAEjC,IAAIE,EAAYL,EAAKZ,OAErB,SAASkB,EAAcC,GACfF,IAAcL,EAAKZ,QAAQY,EAAKI,KAAKJ,EAAKZ,OAAS,GACvD,IAAMoB,EAAMH,EAIZ,OAHAA,EAAYL,EAAKQ,GAEjBR,EAAKQ,GAAOD,EACLC,EAKJ,SAASC,IACZ,OAAOnF,OAGX,IAAIoF,GAAgB,GAEpB,SAASC,GAAkBJ,GACvB,GAAqB,GAAjBG,GAAoB,MAAM,IAAIE,MAAM,mBAExC,OADAZ,IAAOU,IAAiBH,EACjBG,GAGX,SAASG,GAAUL,GAAO,OAAOR,EAAKQ,GAEtC,SAASM,GAAWN,GACZA,EAAM,KACVR,EAAKQ,GAAOH,EACZA,EAAYG,GAGhB,SAASO,GAAWP,GAChB,IAAMQ,EAAMH,GAAUL,GAEtB,OADAM,GAAWN,GACJQ,EAQJ,SAASC,GAAaC,EAAQC,GACjC,IACI,OAAOJ,GAAWzF,IAAkBqF,GAAkBO,GAASP,GAAkBQ,KADrF,QAIInB,EAAKU,WAAmBP,EACxBH,EAAKU,WAAmBP,GAazB,SAASiB,GAAaF,EAAQC,EAAKE,GACtC,IAAMtC,EAAOsC,EAAUvF,IAEvB,OADAuF,EAAUvF,IAAM,EACTR,KAAkBgF,EAAcY,GAASZ,EAAca,GAAMpC,GAUjE,SAASuC,GAAWJ,EAAQC,GAC/B,OAAOlF,GAAYC,OAAOZ,KAAgBgF,EAAcY,GAASZ,EAAca,KAW5E,SAASI,GAAQC,EAASC,EAAGC,EAAGC,GACnC,OAAOC,GAAI1F,OAAOZ,KAAagF,EAAckB,GAAUC,EAAGC,EAAGC,IAGjE,SAASE,GAAmB/F,EAAKgG,GAC7B,OAAO1G,IAAiBuE,SAAS7D,EAAM,EAAGA,EAAM,EAAIgG,GAGxD,IAAIC,GAA0B,KAC9B,SAASC,KAIL,OAHgC,OAA5BD,KACAA,GAA0BzG,OAEvByG,GAGX,IAAIE,GAAuB,KAC3B,SAASC,KAIL,OAH6B,OAAzBD,IAAiCA,GAAqB5G,SAAWC,KAAYD,SAC7E4G,GAAuB,IAAIE,YAAY7G,KAAYD,SAEhD4G,GAMJ,SAASG,GAAcZ,GAC1B,IAAMa,EAASL,KACf1G,KAAmB+G,EAAQ/B,EAAckB,IACzC,IAAMlC,EAAM4C,KACNI,EAAUhD,EAAI+C,EAAS,GACvBE,EAAUjD,EAAI+C,EAAS,EAAI,GAE3BG,EAAUX,GAAmBS,EAASC,GAAS9C,QAErD,OADAnE,IAAqBgH,EAAmB,EAAVC,GACvBC,EASJ,SAASC,GAAcpG,GAC1B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZiF,GAAWzF,KAAmBO,IAqBlC,SAASwD,GAAOhD,EAAcqG,EAAerD,GAChD,IAAMxD,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAYO,EAAM6G,EAAerD,IAoBxD,SAASsD,GAAWhG,EAAKiG,GAC5B,IAAM/G,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAgBO,EAAM+G,IAoB7C,SAASC,GAAalG,EAAKiG,GAC9B,IAAM/G,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAkBO,EAAM+G,IAkB/C,SAASE,GAAYnG,EAAKiG,GAC7B,IAAM/G,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAiBO,EAAM+G,IAsB9C,SAASG,GAAiB1G,EAAcgD,EAAQqD,EAAeM,GAClE,IAAMnH,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAsBO,EAAMwD,EAAQqD,EAAeM,IAuB1E,SAASC,GAAQ5G,EAAc6G,EAASC,GAC3C,IAAMtH,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOmH,EAAQpH,IACrBoH,EAAQpH,IAAM,EACd,IAAMiD,EAAOoE,EAAQrH,IAErB,OADAqH,EAAQrH,IAAM,EACPG,GAAYC,OAAOZ,IAAaO,EAAME,EAAMgD,IAkBhD,SAASqE,GAAQ/G,GACpB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAaO,IAkBpC,SAASwH,GAAShH,GACrB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAcO,IAkBrC,SAASyH,GAASjH,GACrB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAcO,IAkBrC,SAAS0H,GAAelH,EAAcmH,GACzC,IAAM3H,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAoBO,EAAM2H,IAwBjD,SAASC,GAAKpH,EAAcqH,EAAUC,EAAUC,GACnD,IAAM/H,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAUO,EAAM6H,EAAUC,EAAUC,IAyB3D,SAASC,GAAcxH,EAAcyH,EAASzE,GACjD,IAAMxD,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAmBO,EAAMiI,EAASzE,IAqBzD,SAAS0E,GAAkBpH,EAAK0C,GACnC,IAAMxD,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAuBO,EAAMwD,IAqBpD,SAAS2E,GAAoBrH,EAAK0C,GACrC,IAAMxD,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAyBO,EAAMwD,IAqBtD,SAAS4E,GAAmBtH,EAAK0C,GACpC,IAAMxD,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,IAAwBO,EAAMwD,IA0BrD,SAAS6E,GAAmB7H,EAAc8H,EAAUC,EAASC,EAAUC,GAC1E,IAAMzI,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAwBO,EAAMsI,EAAUC,EAASC,EAAUC,IAyBlF,SAASC,GAAelI,EAAcqH,EAAUC,EAAUC,GAC7D,IAAM/H,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAoBO,EAAM6H,EAAUC,EAAUC,IAwBrE,SAASY,GAAenI,EAAcyH,EAASW,GAClD,IAAM5I,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAoBO,EAAMiI,EAASW,IAoB1D,SAASC,GAAmB/H,EAAK8H,GACpC,IAAM5I,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAwBO,EAAM4I,IAoBrD,SAASE,GAAqBhI,EAAK8H,GACtC,IAAM5I,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAA0BO,EAAM4I,IAoBvD,SAASG,GAAoBjI,EAAK8H,GACrC,IAAM5I,EAAOc,EAAIb,IAEjB,OADAa,EAAIb,IAAM,EACHG,GAAYC,OAAOZ,KAAyBO,EAAM4I,IAsBtD,SAASI,GAAcxI,EAAc8H,EAAUE,GAClD,IAAMxI,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAmBO,EAAMsI,EAAUE,IA0B1D,SAASS,GAAqBzI,EAAc0I,EAAWnI,GAC1D,IAAMf,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOgJ,EAAUjJ,IAEvB,OADAiJ,EAAUjJ,IAAM,EACTG,GAAYC,OAAOZ,KAA0BO,EAAME,EAAMa,IAyB7D,SAASoI,GAAkBrI,EAAKoI,EAAWxI,GAC9C,IAAMV,EAAOc,EAAIb,IACjBa,EAAIb,IAAM,EACV,IAAMC,EAAOgJ,EAAUjJ,IAEvB,OADAiJ,EAAUjJ,IAAM,EACTG,GAAYC,OAAOZ,KAAuBO,EAAME,EAAMQ,IA0B1D,SAAS0I,GAAqBtI,EAAKoI,EAAWxI,GACjD,IAAMV,EAAOc,EAAIb,IACjBa,EAAIb,IAAM,EACV,IAAMC,EAAOgJ,EAAUjJ,IAEvB,OADAiJ,EAAUjJ,IAAM,EACTG,GAAYC,OAAOZ,KAA0BO,EAAME,EAAMQ,IA0B7D,SAAS2I,GAAmBvI,EAAKoI,EAAWxI,GAC/C,IAAMV,EAAOc,EAAIb,IACjBa,EAAIb,IAAM,EACV,IAAMC,EAAOgJ,EAAUjJ,IAEvB,OADAiJ,EAAUjJ,IAAM,EACTG,GAAYC,OAAOZ,KAAwBO,EAAME,EAAMQ,IAyB3D,SAAS4I,GAAoB9I,EAAc0I,GAC9C,IAAMlJ,EAAOQ,EAAaP,IAC1BO,EAAaP,IAAM,EACnB,IAAMC,EAAOgJ,EAAUjJ,IAEvB,OADAiJ,EAAUjJ,IAAM,EACTG,GAAYC,OAAOZ,KAAyBO,EAAME,IAoCtD,SAASqJ,GAAOzI,EAAK0I,GACxB,IAAMxJ,EAAOc,EAAIb,IACjBa,EAAIb,IAAM,EACV,IAAMC,EAAOhB,EAAiBsK,GACxBrJ,EAAOhB,EACb,IACI,OAAOiB,GAAYC,OAAOZ,IAAYO,EAAME,EAAMC,IADtD,QAIIV,IAAqBS,EAAa,EAAPC,IAmB5B,SAASsJ,GAAKjJ,GACjB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAUO,IAgBjC,SAAS0J,GAAIlJ,GAChB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAASO,IAgBhC,SAAS2J,GAAInJ,GAChB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAASO,IAOhC,SAAS4J,GAAgBC,GAC5B,IAAM7J,EAAOd,EAAiB2K,GACxBC,EAAO3K,EACPqH,EAASL,KACf,IACI1G,IAAqB+G,EAAQxG,EAAM8J,GACnC,IAAMrG,EAAM4C,KACNI,EAAUhD,EAAI+C,EAAS,GACvBE,EAAUjD,EAAI+C,EAAS,EAAI,GAE3BG,EAAUX,GAAmBS,EAASC,GAAS9C,QAErD,OADAnE,IAAqBgH,EAAmB,EAAVC,GACvBC,EARX,QAYIlH,IAAqBO,EAAa,EAAP8J,IA+B5B,SAASC,GAAWvJ,EAAcqH,EAAUC,EAAUC,GACzD,IAAM/H,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAgBO,EAAM6H,EAAUC,EAAUC,IAmBjE,SAASiC,GAAMxJ,GAClB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAWO,IAkBlC,SAASiK,GAAUzJ,GACtB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAeO,IAkBtC,SAASkK,GAA0B1J,GACtC,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAA+BO,IAkBtD,SAASmK,GAAW3J,GACvB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAgBO,IAiBvC,SAASoK,GAAc5J,GAC1B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAmBO,IAiB1C,SAASqK,GAAc7J,GAC1B,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAmBO,IAkB1C,SAASsK,GAAiB9J,EAAc+J,GAC3C,IAAMvK,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAsBO,EAAMuK,IAgBnD,SAASC,GAAYhK,GACxB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAiBO,IAgBxC,SAASyK,GAAYjK,GACxB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAiBO,IAgBxC,SAAS0K,GAAYlK,GACxB,IAAMR,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,IAAiBO,IAkBxC,SAAS2K,GAAyBnK,EAAcyH,GACnD,IAAMjI,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAA8BO,EAAMiI,IAoB3D,SAAS2C,GAAUpK,EAAcoK,GACpC,IAAM5K,EAAOQ,EAAaP,IAE1B,OADAO,EAAaP,IAAM,EACZG,GAAYC,OAAOZ,KAAeO,EAAM4K,IAGnD,IAAIC,GAAoB,IAAIC,YAAY,SAExC,SAASC,GAAkB9K,EAAKgG,GAC5B,OAAO4E,GAAkBG,OAAOzL,IAAiBuE,SAAS7D,EAAKA,EAAMgG,IAGlE,SAASgF,GAA6BC,EAAMC,GAC/C,IAAIC,EAAQL,GAAkBG,EAAMC,GAEpCC,EAAQA,EAAMxH,QACdnE,IAAqByL,EAAa,EAAPC,GAE3BE,QAAQC,MAAMF,GAGX,SAASG,KACZ,OAAO9G,EAAc,IAAIM,OAGtB,SAASyG,GAA6BrG,EAAK+F,GAE9C,IAAM1E,EAAStH,EAAiB8F,GAAUkG,GAAMO,OAC1CC,EAASvM,EACTsE,EAAM4C,KACZ5C,EAAI0B,EAAM,GAAKqB,EACf/C,EAAI0B,EAAM,EAAI,GAAKuG,EAIvB,SAASC,GAAYC,EAAQC,GACzB,IAAMhI,EAAOwC,KACbxC,EAAK+H,EAAS,GAAK,EACnB/H,EAAK+H,EAAS,EAAI,GAAKnH,EAAcoH,GAGlC,SAASC,GAAiDZ,EAAMC,EAAMY,EAAMC,EAAMC,EAAML,GAC3F,IACI,OAAOnH,EAAcO,GAAUkG,GAAM9F,aAAa+F,EAAMY,EAAMC,EAAMC,IACtE,MAAOJ,GACLF,GAAYC,EAAQC,IAIrB,SAASK,GAAiDhB,EAAMC,EAAMY,EAAMC,EAAMJ,GACrF,IACI5G,GAAUkG,GAAM3F,aAAaP,GAAUmG,GAAOY,EAAMC,GACtD,MAAOH,GACLF,GAAYC,EAAQC,IAIrB,SAASM,GAAiCjB,EAAMC,EAAMY,EAAMH,GAC/D,IAAIQ,EAAQrB,GAAkBI,EAAMY,GACpC,IACI,OAAOtH,EAAcO,GAAUkG,GAAMmB,cAAcD,IACrD,MAAOP,GACLF,GAAYC,EAAQC,IAI5B,SAASS,GAAWxM,GAChB,OAAOA,QAGJ,SAASyM,GAAuBrB,GAEnC,IAAMsB,EAAMxH,GAAUkG,GAAMuB,KAC5B,OAAOH,GAAWE,GAAO,EAAI/H,EAAc+H,GAIxC,SAASE,GAAiCxB,GAC7C,OAAOlG,GAAUkG,GAAMyB,MAGpB,SAASC,GAAkC1B,GAC9C,OAAOlG,GAAUkG,GAAM2B,OAG3B,IAAIC,GAA6B,KAQjC,SAASC,GAA0B9M,EAAKgG,GACpC,OAPmC,OAA/B6G,IAAuCA,GAA2BtN,SAAWC,KAAYD,SACzFsN,GAA6B,IAAIE,kBAAkBvN,KAAYD,SAE5DsN,IAIwBhJ,SAAS7D,EAAM,EAAGA,EAAM,EAAIgG,GAGxD,SAASgH,GAAoD/B,EAAMC,EAAMY,EAAMC,EAAMJ,GACxF,IAAIR,EAAQ2B,GAA0B7B,EAAMC,GAC5C,IACI,OAAO1G,EAAc,IAAIyI,UAAU9B,EAAOW,IAAS,EAAGC,IAAS,IACjE,MAAOH,GACLF,GAAYC,EAAQC,IAWrB,SAASsB,GAAwBhI,EAAK+F,GAEzC,IATsB7H,EAChBpD,EAQAuG,GATgBnD,EASU2B,GAAUkG,GAAMkC,KAR1CnN,EAAMR,IAAoC,EAAb4D,EAAIE,QACvChE,IAAiB2E,IAAIb,EAAKpD,EAAM,GAChCd,EAAkBkE,EAAIE,OACftD,GAMDyL,EAASvM,EACTsE,EAAM4C,KACZ5C,EAAI0B,EAAM,GAAKqB,EACf/C,EAAI0B,EAAM,EAAI,GAAKuG,EAIhB,SAAS2B,GAA2BnC,EAAMC,EAAMS,GACnD,IACI,OAAOnH,EAAcO,GAAUkG,GAAMoC,YAAYtI,GAAUmG,KAC7D,MAAOU,GACLF,GAAYC,EAAQC,IAIrB,SAAS0B,GAA+BrC,EAAMC,EAAMY,GACvD,IAAIK,EAAgB,GAARjB,OAAY7G,EAAYyG,GAAkBI,EAAMY,GAC5D/G,GAAUkG,GAAMsC,YAAcpB,EAG3B,SAASqB,GAAyB9I,GAAO,OAAOK,GAAUL,aAAgB+I,OAAS,EAAI,EAEvF,SAASC,GAAyBzC,GAErC,IAAMsB,EAAMxH,GAAUkG,GAAM0C,SAC5B,OAAOtB,GAAWE,GAAO,EAAI/H,EAAc+H,GAIxC,SAASqB,GAAiC3C,EAAMC,GACnD,IAAIC,EAAQL,GAAkBG,EAAMC,GACpC,OAAO1G,EAAc,IAAIqJ,SAAS1C,IAG/B,SAAS2C,GAA4B7C,EAAMC,EAAMS,GACpD,IACI,OAAOnH,EAAcO,GAAUkG,GAAM8C,KAAKhJ,GAAUmG,KACtD,MAAOU,GACLF,GAAYC,EAAQC,IAIrB,SAASoC,GAAwBC,EAAGC,GACvC,IAmEEC,EAAWC,OAAOC,UAAUF,SAE5BG,EApEF,SADMC,EACNhC,GAEI,IAAMiC,EAAIC,EAAUlC,GACpB,GAAY,UAARiC,GAA4B,WAARA,GAA4B,MAAPjC,EACzC,SAAAmC,OAAWnC,GAEf,GAAY,UAARiC,EACA,UAAAE,OAAWnC,EAAX,KAEJ,GAAY,UAARiC,EAAkB,CAClB,IAAMG,EAAcpC,EAAIoC,YACxB,OAAmB,MAAfA,EACO,SAEP,UAAAD,OAAiBC,EAAjB,KAGR,GAAY,YAARH,EAAoB,CACpB,IAAMI,EAAOrC,EAAIqC,KACjB,MAAmB,iBAARA,GAAoBA,EAAKtL,OAAS,EACzC,YAAAoL,OAAmBE,EAAnB,KAEO,WAIf,GAAIzK,MAAM0K,QAAQtC,GAAM,CACpB,IAAMjJ,EAASiJ,EAAIjJ,OACfgL,EAAQ,IACRhL,EAAS,IACTgL,GAASC,EAAUhC,EAAI,KAE3B,IAAI,IAAI0B,EAAI,EAAGA,EAAI3K,EAAQ2K,IACvBK,GAAS,KAAOC,EAAUhC,EAAI0B,IAGlC,OADAK,GAAS,IAIb,IACIQ,EADEC,EAAiB,sBAAsBC,KAAKb,EAASJ,KAAKxB,IAEhE,KAAIwC,EAAezL,OAAS,GAIxB,OAAO6K,EAASJ,KAAKxB,GAEzB,GAAiB,WALbuC,EAAYC,EAAe,IAS3B,IACI,MAAO,UAAYE,KAAKC,UAAU3C,GAAO,IAC3C,MAAO4C,GACL,MAAO,SAIf,OAAI5C,aAAezH,MACnB,GAAA4J,OAAUnC,EAAIqC,KAAd,MAAAF,OAAuBnC,EAAI6C,QAA3B,cAAAV,OACEnC,EAAIf,OAGHsD,EAKGP,CADFxJ,GAAUkJ,IAEhBjO,EAAMf,EAAiBqP,GAE7B,OADAlI,KAAkB8H,EAAU,GAAKhP,EAC1Bc,EAGA,SAASqP,GAAmB3K,GAAO,MAAMO,GAAWP,GAEpD,SAAS4K,GAAiBtP,EAAKgG,GAClC,MAAM,IAAIlB,MAAMgG,GAAkB9K,EAAKgG,IAWpC,IAAM7F,GAAb,oBAAAA,IAAAoP,EAAAC,KAAArP,GAAA,OAAAsP,EAAAtP,EAAA,EAAAuP,IAAA,OAAAC,MAAA,WAUQ,IAAM3P,EAAMwP,KAAKxP,IACjBwP,KAAKxP,IAAM,EAnBnB,SAAyBA,GAErBR,IAA4BQ,GAkBxB4P,CAAgB5P,KAZxB,CAAA0P,IAAA,MAAAC,MAAA,SAqBQE,EAAUnD,EAAOE,GACjB,OAAOzM,EAAYC,OAAOZ,KAAqBgQ,KAAKxP,IAAKwE,EAAcqL,GAAWnD,EAAOE,OAtBjG,EAAA8C,IAAA,SAAAC,MAAA,SAEkB3P,GACV,IAAMyE,EAAM2J,OAAO0B,OAAO3P,EAAYkO,WAGtC,OAFA5J,EAAIzE,IAAMA,EAEHyE,MANftE,EAAA,GAgCO,IAAM2F,GAAb,oBAAAA,IAAAyJ,EAAAC,KAAA1J,GAAA,OAAA2J,EAAA3J,EAAA,EAAA4J,IAAA,OAAAC,MAAA,WAUQ,IAAM3P,EAAMwP,KAAKxP,IACjBwP,KAAKxP,IAAM,EAjBnB,SAAiBA,GAEbR,IAAoBQ,GAgBhB+P,CAAQ/P,KAZhB,CAAA0P,IAAA,MAAAC,MAAA,SAgDQhK,EAAGC,EAAGC,GACN,OAAOC,EAAI1F,OAAOZ,KAAagQ,KAAKxP,IAAK2F,EAAGC,EAAGC,MAjDvD,CAAA6J,IAAA,IAAAM,IAAA,WAmBQ,OAAOxQ,IAAqBgQ,KAAKxP,MAnBzCiE,IAAA,SAqBUgH,GACF,OAAOzL,IAAqBgQ,KAAKxP,IAAKiL,KAtB9C,CAAAyE,IAAA,IAAAM,IAAA,WA4BQ,OAAOxQ,IAAqBgQ,KAAKxP,MA5BzCiE,IAAA,SA8BUgH,GACF,OAAOzL,IAAqBgQ,KAAKxP,IAAKiL,KA/B9C,CAAAyE,IAAA,IAAAM,IAAA,WAqCQ,OAAOxQ,IAAqBgQ,KAAKxP,MArCzCiE,IAAA,SAuCUgH,GACF,OAAOzL,IAAqBgQ,KAAKxP,IAAKiL,MAxC9C,EAAAyE,IAAA,SAAAC,MAAA,SAEkB3P,GACV,IAAMyE,EAAM2J,OAAO0B,OAAOhK,EAAIuI,WAG9B,OAFA5J,EAAIzE,IAAMA,EAEHyE,MANfqB,EAAA,GAqDO,SAASmK,GAA4BvL,GACxC,OAAOF,EAAcO,GAAUL,IAG5B,SAASwL,GAA2BjC,GAAKjJ,GAAWiJ","file":"3.bundle_b6c47847a8e7e815e45c.js","sourcesContent":["import * as wasm from './photon_bg';\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nlet passStringToWasm;\nif (typeof cachedTextEncoder.encodeInto === 'function') {\n    passStringToWasm = function(arg) {\n\n\n        let size = arg.length;\n        let ptr = wasm.__wbindgen_malloc(size);\n        let offset = 0;\n        {\n            const mem = getUint8Memory();\n            for (; offset < arg.length; offset++) {\n                const code = arg.charCodeAt(offset);\n                if (code > 0x7F) break;\n                mem[ptr + offset] = code;\n            }\n        }\n\n        if (offset !== arg.length) {\n            arg = arg.slice(offset);\n            ptr = wasm.__wbindgen_realloc(ptr, size, size = offset + arg.length * 3);\n            const view = getUint8Memory().subarray(ptr + offset, ptr + size);\n            const ret = cachedTextEncoder.encodeInto(arg, view);\n\n            offset += ret.written;\n        }\n        WASM_VECTOR_LEN = offset;\n        return ptr;\n    };\n} else {\n    passStringToWasm = function(arg) {\n\n\n        let size = arg.length;\n        let ptr = wasm.__wbindgen_malloc(size);\n        let offset = 0;\n        {\n            const mem = getUint8Memory();\n            for (; offset < arg.length; offset++) {\n                const code = arg.charCodeAt(offset);\n                if (code > 0x7F) break;\n                mem[ptr + offset] = code;\n            }\n        }\n\n        if (offset !== arg.length) {\n            const buf = cachedTextEncoder.encode(arg.slice(offset));\n            ptr = wasm.__wbindgen_realloc(ptr, size, size = offset + buf.length);\n            getUint8Memory().set(buf, ptr + offset);\n            offset += buf.length;\n        }\n        WASM_VECTOR_LEN = offset;\n        return ptr;\n    };\n}\n/**\n* Add text to an image.\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @returns {PhotonImage}\n*/\nexport function draw_text_with_border(photon_img, text, x, y) {\n    const ptr0 = photon_img.ptr;\n    photon_img.ptr = 0;\n    const ptr1 = passStringToWasm(text);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.draw_text_with_border(ptr0, ptr1, len1, x, y));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Add bordered-text to an image.\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @returns {PhotonImage}\n*/\nexport function draw_text(photon_img, text, x, y) {\n    const ptr0 = photon_img.ptr;\n    photon_img.ptr = 0;\n    const ptr1 = passStringToWasm(text);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.draw_text(ptr0, ptr1, len1, x, y));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Image manipulation effects in the LCh colour space\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function lch(photon_image, mode, amt) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.lch(ptr0, ptr1, len1, amt));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Image manipulation effects in the HSL colour space\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function hsl(photon_image, mode, amt) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.hsl(ptr0, ptr1, len1, amt));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Image manipulation in the HSV colour space.\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function hsv(photon_image, mode, amt) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.hsv(ptr0, ptr1, len1, amt));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSL colour space.\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {PhotonImage}\n*/\nexport function hue_rotate_hsl(img, degrees) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.hue_rotate_hsl(ptr0, degrees));\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSV colour space.\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {PhotonImage}\n*/\nexport function hue_rotate_hsv(img, degrees) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.hue_rotate_hsv(ptr0, degrees));\n}\n\n/**\n* Shift hue by a specified number of degrees in the LCh colour space.\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {PhotonImage}\n*/\nexport function hue_rotate_lch(img, degrees) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.hue_rotate_lch(ptr0, degrees));\n}\n\n/**\n* Increase the image\\'s saturation by converting each pixel\\'s colour to the HSL colour space\n* and increasing the colour\\'s saturation.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function saturate_hsl(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.saturate_hsl(ptr0, level));\n}\n\n/**\n* Increase the image\\'s saturation in the LCh colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function saturate_lch(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.saturate_lch(ptr0, level));\n}\n\n/**\n* Increase the image\\'s saturation in the HSV colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function saturate_hsv(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.saturate_hsv(ptr0, level));\n}\n\n/**\n* Lighten an image by a specified amount in the LCh colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function lighten_lch(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.lighten_lch(ptr0, level));\n}\n\n/**\n* Lighten an image by a specified amount in the HSL colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function lighten_hsl(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.lighten_hsl(ptr0, level));\n}\n\n/**\n* Lighten an image by a specified amount in the HSV colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function lighten_hsv(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.lighten_hsv(ptr0, level));\n}\n\n/**\n* Darken the image by a specified amount in the LCh colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function darken_lch(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.darken_lch(ptr0, level));\n}\n\n/**\n* Darken the image by a specified amount in the HSL colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function darken_hsl(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.darken_hsl(ptr0, level));\n}\n\n/**\n* Darken the image\\'s colours by a specified amount in the HSV colour space.\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {PhotonImage}\n*/\nexport function darken_hsv(img, level) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.darken_hsv(ptr0, level));\n}\n\n/**\n* Noise reduction.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to sharpen an image:\n* use photon::conv::sharpen;\n* photon::channels::sharpen(img);\n* ```\n* Adds a constant to a select R, G, or B channel\\'s value.\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function noise_reduction(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.noise_reduction(ptr0));\n}\n\n/**\n* Sharpen an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to sharpen an image:\n* use photon::conv::sharpen;\n* photon::channels::sharpen(img);\n* ```\n* Adds a constant to a select R, G, or B channel\\'s value.\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function sharpen(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.sharpen(ptr0));\n}\n\n/**\n* Apply edge detection to an image, to create a dark version with its edges highlighted.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* photon::conv::edge_detection(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function edge_detection(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.edge_detection(ptr0));\n}\n\n/**\n* Apply an identity kernel convolution to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply an identity kernel convolution:\n* use photon::channels;\n* photon::conv::identity(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function identity(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.identity(ptr0));\n}\n\n/**\n* Apply a box blur effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a box blur effect:\n* use photon::channels;\n* photon::conv::box_blur(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function box_blur(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.box_blur(ptr0));\n}\n\n/**\n* Apply a gaussian blur effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a gaussian blur effect to an image:\n* use photon::channels;\n* photon::conv::gaussian_blur(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function gaussian_blur(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.gaussian_blur(ptr0));\n}\n\n/**\n* Detect horizontal lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the horizontal lines in an image:\n* use photon::channels;\n* photon::conv::detect_horizontal_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function detect_horizontal_lines(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.detect_horizontal_lines(ptr0));\n}\n\n/**\n* Detect vertical lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the vertical lines in an image:\n* use photon::channels;\n* photon::conv::detect_vertical_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function detect_vertical_lines(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.detect_vertical_lines(ptr0));\n}\n\n/**\n* Detect lines at a forty five degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the lines at a forty five degree angle in an image:\n* use photon::channels;\n* photon::conv::detect_fortyfivedeg_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function detect_45_deg_lines(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.detect_45_deg_lines(ptr0));\n}\n\n/**\n* Detect lines at a 135 degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the lines at a 135 degree angle in an image:\n* use photon::channels;\n* photon::conv::detect_hundredthirtyfive_deg_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function detect_135_deg_lines(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.detect_135_deg_lines(ptr0));\n}\n\n/**\n* Apply a standard laplace convolution.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a laplace effect:\n* use photon::conv;\n* photon::conv::laplace(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function laplace(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.laplace(ptr0));\n}\n\n/**\n* Preset edge effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply this effect:\n* use photon::conv;\n* photon::conv::edge_one(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function edge_one(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.edge_one(ptr0));\n}\n\n/**\n* Apply an emboss effect to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply an emboss effect:\n* use photon::conv;\n* photon::conv::emboss(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function emboss(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.emboss(ptr0));\n}\n\n/**\n* Apply a horizontal Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a horizontal Sobel filter:\n* use photon::conv;\n* photon::conv::sobel_horizontal(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function sobel_horizontal(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.sobel_horizontal(ptr0));\n}\n\n/**\n* Apply a horizontal Prewitt convolution to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a horizontal Prewitt convolution effect:\n* use photon::conv;\n* photon::conv::prewitt_horizontal(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function prewitt_horizontal(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.prewitt_horizontal(ptr0));\n}\n\n/**\n* Apply a vertical Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a vertical Sobel filter:\n* use photon::conv;\n* photon::conv::sobel_vertical(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function sobel_vertical(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.sobel_vertical(ptr0));\n}\n\n/**\n* Add randomized noise to an image.\n* This function adds a Gaussian Noise Sample to each pixel through incrementing each channel by a randomized offset.\n* This randomized offset is generated by creating a randomized thread pool.\n*\n* # Arguments\n* * `name` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example:\n* use photon::noise;\n* photon::noise::add_noise_rand(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function add_noise_rand(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.add_noise_rand(ptr0));\n}\n\n/**\n* Add pink-tinted noise to an image.\n*\n* # Arguments\n* * `name` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to add pink-tinted noise to an image:\n* use photon::noise;\n* photon::noise::pink_noise(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function pink_noise(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.pink_noise(ptr0));\n}\n\n/**\n* Add a watermark to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `watermark` - The watermark to be placed onto the `img` image.\n* * `x` - The x coordinate where the watermark\\'s top corner should be positioned.\n* * `y` - The y coordinate where the watermark\\'s top corner should be positioned.\n* # Example\n*\n* ```\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon::multiple;\n* photon::multiple::watermark(img, watermark, 30, 40);\n* ```\n* @param {PhotonImage} img\n* @param {PhotonImage} watermark\n* @param {number} x\n* @param {number} y\n* @returns {PhotonImage}\n*/\nexport function watermark(img, watermark, x, y) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    const ptr1 = watermark.ptr;\n    watermark.ptr = 0;\n    return PhotonImage.__wrap(wasm.watermark(ptr0, ptr1, x, y));\n}\n\n/**\n* Add a rotated watermark to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `watermark` - The watermark to be placed onto the `img` image.\n* * `x` - The x coordinate where the watermark\\'s top corner should be positioned.\n* * `y` - The y coordinate where the watermark\\'s top corner should be positioned.\n* * `degrees` - The number of degrees the watermark should be rotated by.\n* # Example\n*\n* ```\n* // For example, to rotate the watermark by 30 degrees and place it at x: 30, y: 40:\n* use photon::multiple;\n* photon::multiple::watermark(img, watermark, 30, 40, 120);\n* ```\n* Blend two images together.\n* The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n* The blend modes available include: `overlay`, `over`, `atop`, `xor`, `multiply`, `burn`, `soft_light`, `hard_light`\n* `difference`, `lighten`, `darken`, `dodge`, `plus`, `exclusion` (more to come)\n* NOTE: The first image must be smaller than the second image passed as params.\n* If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n* in the second image.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `img2` - The 2nd DynamicImage to be blended with the first.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon::multiple;\n* photon::multiple::watermark(img, watermark, 30, 40);\n* ```\n* @param {PhotonImage} photon_image\n* @param {PhotonImage} photon_image2\n* @param {string} blend_mode\n* @returns {PhotonImage}\n*/\nexport function blend(photon_image, photon_image2, blend_mode) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = photon_image2.ptr;\n    photon_image2.ptr = 0;\n    const ptr2 = passStringToWasm(blend_mode);\n    const len2 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.blend(ptr0, ptr1, ptr2, len2));\n\n    } finally {\n        wasm.__wbindgen_free(ptr2, len2 * 1);\n\n    }\n\n}\n\nconst heap = new Array(32);\n\nheap.fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n* @returns {void}\n*/\nexport function run() {\n    return wasm.run();\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* Get the ImageData from a 2D canvas context\n* @param {any} canvas\n* @param {any} ctx\n* @returns {any}\n*/\nexport function getImageData(canvas, ctx) {\n    try {\n        return takeObject(wasm.getImageData(addBorrowedObject(canvas), addBorrowedObject(ctx)));\n\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n\n    }\n\n}\n\n/**\n* Place the ImageData onto the 2D context.\n* @param {any} canvas\n* @param {any} ctx\n* @param {PhotonImage} new_image\n* @returns {void}\n*/\nexport function putImageData(canvas, ctx, new_image) {\n    const ptr2 = new_image.ptr;\n    new_image.ptr = 0;\n    return wasm.putImageData(addHeapObject(canvas), addHeapObject(ctx), ptr2);\n}\n\n/**\n* Convert the ImageData found in the canvas context to a PhotonImage,\n* which can be used to filter or apply effects to the image\n* @param {any} canvas\n* @param {any} ctx\n* @returns {PhotonImage}\n*/\nexport function open_image(canvas, ctx) {\n    return PhotonImage.__wrap(wasm.open_image(addHeapObject(canvas), addHeapObject(ctx)));\n}\n\n/**\n* Create a new RGB colour. TODO Will be using struct impl soon.\n* @param {any} imgdata\n* @param {number} r\n* @param {number} g\n* @param {number} b\n* @returns {Rgb}\n*/\nexport function new_rgb(imgdata, r, g, b) {\n    return Rgb.__wrap(wasm.new_rgb(addHeapObject(imgdata), r, g, b));\n}\n\nfunction getArrayU8FromWasm(ptr, len) {\n    return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedGlobalArgumentPtr = null;\nfunction globalArgumentPtr() {\n    if (cachedGlobalArgumentPtr === null) {\n        cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();\n    }\n    return cachedGlobalArgumentPtr;\n}\n\nlet cachegetUint32Memory = null;\nfunction getUint32Memory() {\n    if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory;\n}\n/**\n* @param {any} imgdata\n* @returns {Uint8Array}\n*/\nexport function to_raw_pixels(imgdata) {\n    const retptr = globalArgumentPtr();\n    wasm.to_raw_pixels(retptr, addHeapObject(imgdata));\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n    return realRet;\n\n}\n\n/**\n* Convert a PhotonImage to JS-compatible ImageData\n* @param {PhotonImage} photon_image\n* @returns {any}\n*/\nexport function to_image_data(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return takeObject(wasm.to_image_data(ptr0));\n}\n\n/**\n* Adds an offset to the image by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```\n* // For example, to offset pixels by 30 pixels on the red channel:\n* use photon::effects;\n* photon::effects::offset(img, 0, 30);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel_index\n* @param {number} offset\n* @returns {PhotonImage}\n*/\nexport function offset(photon_image, channel_index, offset) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.offset(ptr0, channel_index, offset));\n}\n\n/**\n* Adds an offset to the red channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The offset you want to move the red channel by.\n* # Example\n*\n* ```\n* // For example, to add an offset to the red channel by 30 pixels.\n* use photon::effects;\n* photon::effects::offset_red(img, 30);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {PhotonImage}\n*/\nexport function offset_red(img, offset_amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.offset_red(ptr0, offset_amt));\n}\n\n/**\n* Adds an offset to the green channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The offset you want to move the green channel by.\n* # Example\n*\n* ```\n* // For example, to add an offset to the green channel by 30 pixels.\n* use photon::effects;\n* photon::effects::offset_green(img, 40);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {PhotonImage}\n*/\nexport function offset_green(img, offset_amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.offset_green(ptr0, offset_amt));\n}\n\n/**\n* Adds an offset to the blue channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset_amt` - The offset you want to move the blue channel by.\n* # Example\n* // For example, to add an offset to the green channel by 40 pixels.\n* use photon::effects;\n* photon::effects::offset_blue(img, 40);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {PhotonImage}\n*/\nexport function offset_blue(img, offset_amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.offset_blue(ptr0, offset_amt));\n}\n\n/**\n* Adds multiple offsets to the image by a certain number of pixels (on two channels).\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```\n* // For example, to add a 30-pixel offset to both the red and blue channels:\n* use photon::effects;\n* photon::effects::multiple_offsets(img, 30, 0, 2);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} offset\n* @param {number} channel_index\n* @param {number} channel_index2\n* @returns {PhotonImage}\n*/\nexport function multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.multiple_offsets(ptr0, offset, channel_index, channel_index2));\n}\n\n/**\n* Pass the image through a duotone filter (comprising two colours, and their gradient from one colour to the other).\n* This is similar to greyscaling an image, but rather than having the gradient transition from black to white, it should\n* be between two other colours, red to green, for example.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `color_a` - An RGB color.\n* * `color_b` - An RGB color.\n* # Example\n*\n* ```\n* // For example, to pass an image through a duotone filter:\n* use photon::effects;\n* photon::effects::duotone(img, colour_a, colour_b);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} color_a\n* @param {Rgb} color_b\n* @returns {PhotonImage}\n*/\nexport function duotone(photon_image, color_a, color_b) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = color_a.ptr;\n    color_a.ptr = 0;\n    const ptr2 = color_b.ptr;\n    color_b.ptr = 0;\n    return PhotonImage.__wrap(wasm.duotone(ptr0, ptr1, ptr2));\n}\n\n/**\n* Reduces an image to the primary colours.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to add a primary colour effect to an image of type `DynamicImage`:\n* use photon::effects;\n* photon::effects::primary(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function primary(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.primary(ptr0));\n}\n\n/**\n* Colorizes the green channels of the image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to colorize an image of type `DynamicImage`:\n* use photon::effects;\n* photon::effects::colorize(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function colorize(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.colorize(ptr0));\n}\n\n/**\n* Applies a solarizing effect to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to colorize an image of type `DynamicImage`:\n* use photon::effects;\n* photon::effects::solarize(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function solarize(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.solarize(ptr0));\n}\n\n/**\n* Increase the brightness of an image by a factor.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `brightness` - A u8 to add to the brightness.\n* # Example\n*\n* ```\n* photon::effects::inc_brightness(img, 10);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} brightness\n* @returns {PhotonImage}\n*/\nexport function inc_brightness(photon_image, brightness) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.inc_brightness(ptr0, brightness));\n}\n\n/**\n* Tint an image by adding an offset to averaged RGB channel values.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `r_offset` - The amount the  R channel should be incremented by.\n* * `g_offset` - The amount the G channel should be incremented by.\n* * `b_offset` - The amount the B channel should be incremented by.\n* # Example\n*\n* ```\n* // For example, to tint an image of type `DynamicImage`:\n* photon::tint(img, 10, 20, 15);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n* @returns {PhotonImage}\n*/\nexport function tint(photon_image, r_offset, g_offset, b_offset) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.tint(ptr0, r_offset, g_offset, b_offset));\n}\n\n/**\n* Alter a select channel by incrementing its value by a constant.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `channel` - The channel you wish to inc, it should be either 0, 1 or 2,\n* representing R, G, or B respectively\n* * `offset` - The amount you want to increment the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* photon::channels::alter_channel(img, 0, 10);\n* ```\n* Adds a constant to a select R, G, or B channel\\'s value.\n* @param {PhotonImage} photon_image\n* @param {number} channel\n* @param {number} offset\n* @returns {PhotonImage}\n*/\nexport function alter_channel(photon_image, channel, offset) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_channel(ptr0, channel, offset));\n}\n\n/**\n* Increment or decrement every pixel\\'s Red channel by a constant.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The amount you want to increment the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* photon::channels::alter_red_channel(img, 10);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset\n* @returns {PhotonImage}\n*/\nexport function alter_red_channel(img, offset) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_red_channel(ptr0, offset));\n}\n\n/**\n* Increment every pixel\\'s Green channel by a constant.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The amount you want to increment the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Green channel for all pixels by 20:\n* use photon::channels;\n* photon::channels::alter_green_channel(img, 10);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset\n* @returns {PhotonImage}\n*/\nexport function alter_green_channel(img, offset) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_green_channel(ptr0, offset));\n}\n\n/**\n* Increment or decrement every pixel\\'s Blue channel by a constant.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `offset` - The amount you want to increment the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Blue channel for all pixels by 10:\n* use photon::channels;\n* photon::channels::alter_blue_channel(img, 10);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset\n* @returns {PhotonImage}\n*/\nexport function alter_blue_channel(img, offset) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_blue_channel(ptr0, offset));\n}\n\n/**\n* Increment/decrement two channels\\' values simultaneously by adding an offset to each channel per pixel.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `channel1` - A usize that represents an index into the RGB vec.\n* * `offset1` - The amount you want to increment the channel\\'s value by for that pixel.\n* * `channel2` - A usize that represents an index into the RGB vec. 0 would return the Red channel.\n* * `offset2` - The amount you want to increment the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the values of the Red and Blue channels per pixel:\n* photon::channels::inc_two_channels(img, 0, 10, 2, 20);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel1\n* @param {number} offset1\n* @param {number} channel2\n* @param {number} offset2\n* @returns {PhotonImage}\n*/\nexport function alter_two_channels(photon_image, channel1, offset1, channel2, offset2) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_two_channels(ptr0, channel1, offset1, channel2, offset2));\n}\n\n/**\n* Increment all 3 channels\\' values by adding an offset to each channel per pixel.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `r_offset` - The amount you want to increment the Red channel by.\n* * `g_offset` - The amount you want to increment the Green channel by.\n* * `b_offset` - The amount you want to increment the Blue channel by.\n*\n* # Example\n*\n* ```\n* // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n* // and the Blue channel by 50:\n* // photon::channels::alter_channels(img, 10, 20, 50);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n* @returns {PhotonImage}\n*/\nexport function alter_channels(photon_image, r_offset, g_offset, b_offset) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.alter_channels(ptr0, r_offset, g_offset, b_offset));\n}\n\n/**\n* Set a certain channel to zero, thus removing the channel\\'s influence in the pixels\\' final rendered colour.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n* * `min_filter` - Value between 0 and 255. Only remove the channel if the current pixel\\'s channel value is less than this minimum filter. To completely\n* remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n* then channel would be 0 and min_filter would be 50.\n*\n* # Example\n*\n* ```\n* // For example, to remove the Red channel with a min_filter of 100:\n* photon::channels::remove_channel(img, 0, 100);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel\n* @param {number} min_filter\n* @returns {PhotonImage}\n*/\nexport function remove_channel(photon_image, channel, min_filter) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.remove_channel(ptr0, channel, min_filter));\n}\n\n/**\n* Remove the Red channel\\'s influence in an image, by setting its value to zero.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the red channel for red channel pixel values less than 50:\n* photon::channels::remove_red_channel(img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {PhotonImage}\n*/\nexport function remove_red_channel(img, min_filter) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.remove_red_channel(ptr0, min_filter));\n}\n\n/**\n* Remove the Green channel\\'s influence in an image, by setting its value to zero.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the green channel for green channel pixel values less than 50:\n* photon::channels::remove_green_channel(img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {PhotonImage}\n*/\nexport function remove_green_channel(img, min_filter) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.remove_green_channel(ptr0, min_filter));\n}\n\n/**\n* Remove the Blue channel\\'s influence in an image, by setting its value to zero.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the blue channel for blue channel pixel values less than 50:\n* photon::channels::remove_blue_channel(img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {PhotonImage}\n*/\nexport function remove_blue_channel(img, min_filter) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    return PhotonImage.__wrap(wasm.remove_blue_channel(ptr0, min_filter));\n}\n\n/**\n* Swap two channels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n* * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n*\n* # Example\n*\n* ```\n* // For example, to swap the values of the Red channel with the values of the Blue channel:\n* photon::channels::swap_channels(img, 0, 2);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel1\n* @param {number} channel2\n* @returns {PhotonImage}\n*/\nexport function swap_channels(photon_image, channel1, channel2) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.swap_channels(ptr0, channel1, channel2));\n}\n\n/**\n* Selective hue rotation.\n*\n* Only rotate the hue of a pixel if its RGB values are within a specified range.\n* This function only rotates a pixel\\'s hue to another  if it is visually similar to the colour specified.\n* For example, if a user wishes all pixels that are yellow to be changed to red, they can selectively specify  only the yellow pixels to be changed.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `degrees` - The amount of degrees to hue rotate by.\n*\n* # Example\n*\n* ```\n* // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_hue_rotate(img, ref_color, 180);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @param {number} degrees\n* @returns {PhotonImage}\n*/\nexport function selective_hue_rotate(photon_image, ref_color, degrees) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return PhotonImage.__wrap(wasm.selective_hue_rotate(ptr0, ptr1, degrees));\n}\n\n/**\n* Selectively lighten an image.\n*\n* Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n* For example, if a user wishes all pixels that are yellow to be lightened, they can selectively specify  only the yellow pixels to be changed.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n*\n* # Example\n*\n* ```\n* // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_lighten(img, ref_color, 0.2);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function selective_lighten(img, ref_color, amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return PhotonImage.__wrap(wasm.selective_lighten(ptr0, ptr1, amt));\n}\n\n/**\n* Selectively desaturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are yellow to be desaturated by 0.1, they can selectively specify  only the yellow pixels to be changed.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of desaturate the colour by.\n*\n* # Example\n*\n* ```\n* // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_desaturate(img, ref_color, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function selective_desaturate(img, ref_color, amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return PhotonImage.__wrap(wasm.selective_desaturate(ptr0, ptr1, amt));\n}\n\n/**\n* Selectively saturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are yellow to have an increase in saturation by 10%, they can selectively specify only the yellow pixels to be changed.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of saturate the colour by.\n*\n* # Example\n*\n* ```\n* // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_saturate(img, ref_color, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {PhotonImage}\n*/\nexport function selective_saturate(img, ref_color, amt) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return PhotonImage.__wrap(wasm.selective_saturate(ptr0, ptr1, amt));\n}\n\n/**\n* Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n* Only changes the colour of a pixel if its RGB values are within a specified range.\n*\n* (Similarity between two colours is calculated via the CIE76 formula.)\n* For example, if a user wishes all pixels that are *NOT* yellow to be displayed in greyscale, they can selectively specify only the yellow pixels to be\n* kept in the photo.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n*\n* # Example\n*\n* ```\n* // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_greyscale(img, ref_color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @returns {PhotonImage}\n*/\nexport function selective_greyscale(photon_image, ref_color) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return PhotonImage.__wrap(wasm.selective_greyscale(ptr0, ptr1));\n}\n\n/**\n* Apply a filter to an image. Over 20 filters are available.\n* The filters are as follows:\n* * **oceanic**: Add an aquamarine-tinted hue to an image.\n* * **islands**: Aquamarine tint.\n* * **marine**: Add a green/blue mixed hue to an image.\n* * **seagreen**: Dark green hue, with tones of blue.\n* * **flagblue**: Royal blue tint\n* * **liquid**: Blue-inspired tint.\n* * **diamante**: Custom filter with a blue/turquoise tint.\n* * **radio**: Fallout-style radio effect.\n* * **twenties**: Slight-blue tinted historical effect.\n* * **rosetint**: Rose-tinted filter.\n* * **mauve**: Purple-infused filter.\n* * **bluechrome**: Blue monochrome effect.\n* * **vintage**: Vintage filter with a red tint.\n* * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n* * **serenity**: Custom filter with an increase in the Blue channel\\'s values.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `img2` - The 2nd DynamicImage to be blended with the first.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```\n* // For example, to add a filter called \\\"vintage\\\" to an image:\n* use photon::filters;\n* photon::filters::filter(img, \\\"vintage\\\");\n* ```\n* @param {PhotonImage} img\n* @param {string} filter_name\n* @returns {PhotonImage}\n*/\nexport function filter(img, filter_name) {\n    const ptr0 = img.ptr;\n    img.ptr = 0;\n    const ptr1 = passStringToWasm(filter_name);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.filter(ptr0, ptr1, len1));\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Solarization on the Blue channel.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::filters::neue(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function neue(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.neue(ptr0));\n}\n\n/**\n* Solarization on the Red and Green channels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::filters::lix(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function lix(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.lix(ptr0));\n}\n\n/**\n* Solarization on the Red and Blue channels.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::filters::ryo(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function ryo(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.ryo(ptr0));\n}\n\n/**\n* @param {string} base64\n* @returns {Uint8Array}\n*/\nexport function base64_to_image(base64) {\n    const ptr0 = passStringToWasm(base64);\n    const len0 = WASM_VECTOR_LEN;\n    const retptr = globalArgumentPtr();\n    try {\n        wasm.base64_to_image(retptr, ptr0, len0);\n        const mem = getUint32Memory();\n        const rustptr = mem[retptr / 4];\n        const rustlen = mem[retptr / 4 + 1];\n\n        const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n        wasm.__wbindgen_free(rustptr, rustlen * 1);\n        return realRet;\n\n\n    } finally {\n        wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    }\n\n}\n\n/**\n* Apply a monochrome effect of a certain colour.\n*\n* It does so by averaging the R, G, and B values of a pixel, and then adding a\n* separate value to that averaged value for each channel to produce a tint.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `r_offset` - The value to add to the Red channel per pixel.\n* * `g_offset` - The value to add to the Green channel per pixel.\n* * `b_offset` - The value to add to the Blue channel per pixel.\n*\n* # Example\n*\n* ```\n* // For example, to apply a monochrome effect to an image:\n* use photon::monochrome;\n* photon::monochrome::monochroma(img, 40, 50, 100);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n* @returns {PhotonImage}\n*/\nexport function monochrome(photon_image, r_offset, g_offset, b_offset) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.monochrome(ptr0, r_offset, g_offset, b_offset));\n}\n\n/**\n* Convert an image to sepia.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to tint an image of type `DynamicImage`:\n* use photon::channels;\n* photon::channels::sepia(img);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function sepia(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.sepia(ptr0));\n}\n\n/**\n* Convert an image to grayscale using the conventional averaging algorithm.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to convert an image of type `DynamicImage` to greyscale:\n* use photon::channels;\n* photon::channels::grayscale(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function grayscale(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.grayscale(ptr0));\n}\n\n/**\n* Convert an image to grayscale with a human corrected factor, to account for human vision.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to convert an image of type `DynamicImage` to greyscale with a human corrected factor:\n* use photon::channels;\n* photon::channels::grayscale_human_corrected(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function grayscale_human_corrected(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.grayscale_human_corrected(ptr0));\n}\n\n/**\n* Desaturate an image by getting the min/max of each pixel\\'s RGB values.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to desaturate an image:\n* use photon::channels;\n* photon::channels::desaturate(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function desaturate(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.desaturate(ptr0));\n}\n\n/**\n* Uses a min. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to decompose an image with min decomposition:\n* photon::channels::decompose_min(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function decompose_min(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.decompose_min(ptr0));\n}\n\n/**\n* Uses a max. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to decompose an image with max decomposition:\n* photon::channels::decompose_max(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function decompose_max(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.decompose_max(ptr0));\n}\n\n/**\n* Employ only a limited number of gray shades in an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to limit an image to four shades of gray only:\n* photon::channels::grayscale_shades(img, 4);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_shades\n* @returns {PhotonImage}\n*/\nexport function grayscale_shades(photon_image, num_shades) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.grayscale_shades(ptr0, num_shades));\n}\n\n/**\n* Convert an image to grayscale by setting all 3 RGB values to the Red channel\\'s value.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::channels::r_grayscale(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function r_grayscale(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.r_grayscale(ptr0));\n}\n\n/**\n* Convert an image to grayscale by setting all 3 RGB values to the Green channel\\'s value.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::channels::g_grayscale(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function g_grayscale(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.g_grayscale(ptr0));\n}\n\n/**\n* Convert an image to grayscale by setting all 3 RGB values to the Blue channel\\'s value.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```\n* photon::channels::b_grayscale(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function b_grayscale(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.b_grayscale(ptr0));\n}\n\n/**\n* Convert an image to grayscale by setting all 3 RGB values to a chosen channel\\'s value.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green, and 2 the Blue.\n* # Example\n*\n* ```\n* photon::channels::b_grayscale(img);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel\n* @returns {PhotonImage}\n*/\nexport function single_channel_grayscale(photon_image, channel) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.single_channel_grayscale(ptr0, channel));\n}\n\n/**\n* Threshold an image using a standard thresholding algorithm.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `threshold` - The amount the image should be thresholded by.\n* # Example\n*\n* ```\n* // For example, to threshold an image of type `DynamicImage`:\n* use photon::channels;\n* photon::monochrome::threshold(img, 30);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} threshold\n* @returns {PhotonImage}\n*/\nexport function threshold(photon_image, threshold) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return PhotonImage.__wrap(wasm.threshold(ptr0, threshold));\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8');\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nexport function __wbg_error_4bb6c2a97407129a(arg0, arg1) {\n    let varg0 = getStringFromWasm(arg0, arg1);\n\n    varg0 = varg0.slice();\n    wasm.__wbindgen_free(arg0, arg1 * 1);\n\n    console.error(varg0);\n}\n\nexport function __wbg_new_59cb74e423758ede() {\n    return addHeapObject(new Error());\n}\n\nexport function __wbg_stack_558ba5917b466edd(ret, arg0) {\n\n    const retptr = passStringToWasm(getObject(arg0).stack);\n    const retlen = WASM_VECTOR_LEN;\n    const mem = getUint32Memory();\n    mem[ret / 4] = retptr;\n    mem[ret / 4 + 1] = retlen;\n\n}\n\nfunction handleError(exnptr, e) {\n    const view = getUint32Memory();\n    view[exnptr / 4] = 1;\n    view[exnptr / 4 + 1] = addHeapObject(e);\n}\n\nexport function __widl_f_get_image_data_CanvasRenderingContext2D(arg0, arg1, arg2, arg3, arg4, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).getImageData(arg1, arg2, arg3, arg4));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_put_image_data_CanvasRenderingContext2D(arg0, arg1, arg2, arg3, exnptr) {\n    try {\n        getObject(arg0).putImageData(getObject(arg1), arg2, arg3);\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_create_element_Document(arg0, arg1, arg2, exnptr) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    try {\n        return addHeapObject(getObject(arg0).createElement(varg1));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nexport function __widl_f_body_Document(arg0) {\n\n    const val = getObject(arg0).body;\n    return isLikeNone(val) ? 0 : addHeapObject(val);\n\n}\n\nexport function __widl_f_width_HTMLCanvasElement(arg0) {\n    return getObject(arg0).width;\n}\n\nexport function __widl_f_height_HTMLCanvasElement(arg0) {\n    return getObject(arg0).height;\n}\n\nlet cachegetUint8ClampedMemory = null;\nfunction getUint8ClampedMemory() {\n    if (cachegetUint8ClampedMemory === null || cachegetUint8ClampedMemory.buffer !== wasm.memory.buffer) {\n        cachegetUint8ClampedMemory = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachegetUint8ClampedMemory;\n}\n\nfunction getClampedArrayU8FromWasm(ptr, len) {\n    return getUint8ClampedMemory().subarray(ptr / 1, ptr / 1 + len);\n}\n\nexport function __widl_f_new_with_u8_clamped_array_and_sh_ImageData(arg0, arg1, arg2, arg3, exnptr) {\n    let varg0 = getClampedArrayU8FromWasm(arg0, arg1);\n    try {\n        return addHeapObject(new ImageData(varg0, arg2 >>> 0, arg3 >>> 0));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nfunction passArray8ToWasm(arg) {\n    const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n    getUint8Memory().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nexport function __widl_f_data_ImageData(ret, arg0) {\n\n    const retptr = passArray8ToWasm(getObject(arg0).data);\n    const retlen = WASM_VECTOR_LEN;\n    const mem = getUint32Memory();\n    mem[ret / 4] = retptr;\n    mem[ret / 4 + 1] = retlen;\n\n}\n\nexport function __widl_f_append_child_Node(arg0, arg1, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).appendChild(getObject(arg1)));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_set_text_content_Node(arg0, arg1, arg2) {\n    let varg1 = arg1 == 0 ? undefined : getStringFromWasm(arg1, arg2);\n    getObject(arg0).textContent = varg1;\n}\n\nexport function __widl_instanceof_Window(idx) { return getObject(idx) instanceof Window ? 1 : 0; }\n\nexport function __widl_f_document_Window(arg0) {\n\n    const val = getObject(arg0).document;\n    return isLikeNone(val) ? 0 : addHeapObject(val);\n\n}\n\nexport function __wbg_newnoargs_a172f39151049128(arg0, arg1) {\n    let varg0 = getStringFromWasm(arg0, arg1);\n    return addHeapObject(new Function(varg0));\n}\n\nexport function __wbg_call_8a9c8b0a32a202ff(arg0, arg1, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).call(getObject(arg1)));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __wbindgen_debug_string(i, len_ptr) {\n    const debug_str =\n    val => {\n        // primitive types\n        const type = typeof val;\n        if (type == 'number' || type == 'boolean' || val == null) {\n            return  `${val}`;\n        }\n        if (type == 'string') {\n            return `\"${val}\"`;\n        }\n        if (type == 'symbol') {\n            const description = val.description;\n            if (description == null) {\n                return 'Symbol';\n            } else {\n                return `Symbol(${description})`;\n            }\n        }\n        if (type == 'function') {\n            const name = val.name;\n            if (typeof name == 'string' && name.length > 0) {\n                return `Function(${name})`;\n            } else {\n                return 'Function';\n            }\n        }\n        // objects\n        if (Array.isArray(val)) {\n            const length = val.length;\n            let debug = '[';\n            if (length > 0) {\n                debug += debug_str(val[0]);\n            }\n            for(let i = 1; i < length; i++) {\n                debug += ', ' + debug_str(val[i]);\n            }\n            debug += ']';\n            return debug;\n        }\n        // Test for built-in\n        const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n        let className;\n        if (builtInMatches.length > 1) {\n            className = builtInMatches[1];\n        } else {\n            // Failed to match the standard '[object ClassName]'\n            return toString.call(val);\n        }\n        if (className == 'Object') {\n            // we're a user defined class or Object\n            // JSON.stringify avoids problems with cycles, and is generally much\n            // easier than looping through ownProperties of `val`.\n            try {\n                return 'Object(' + JSON.stringify(val) + ')';\n            } catch (_) {\n                return 'Object';\n            }\n        }\n        // errors\n        if (val instanceof Error) {\n        return `${val.name}: ${val.message}\n        ${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n;\nconst toString = Object.prototype.toString;\nconst val = getObject(i);\nconst debug = debug_str(val);\nconst ptr = passStringToWasm(debug);\ngetUint32Memory()[len_ptr / 4] = WASM_VECTOR_LEN;\nreturn ptr;\n}\n\nexport function __wbindgen_rethrow(idx) { throw takeObject(idx); }\n\nexport function __wbindgen_throw(ptr, len) {\n    throw new Error(getStringFromWasm(ptr, len));\n}\n\nfunction freePhotonImage(ptr) {\n\n    wasm.__wbg_photonimage_free(ptr);\n}\n/**\n* Provides the image\\'s height, width, and contains the image\\'s raw pixels.\n* For use when communicating between JS and WASM, and also natively.\n*/\nexport class PhotonImage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PhotonImage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        freePhotonImage(ptr);\n    }\n\n    /**\n    * @param {any} img_data\n    * @param {number} width\n    * @param {number} height\n    * @returns {PhotonImage}\n    */\n    new(img_data, width, height) {\n        return PhotonImage.__wrap(wasm.photonimage_new(this.ptr, addHeapObject(img_data), width, height));\n    }\n}\n\nfunction freeRgb(ptr) {\n\n    wasm.__wbg_rgb_free(ptr);\n}\n/**\n*/\nexport class Rgb {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Rgb.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        freeRgb(ptr);\n    }\n\n    /**\n    * @returns {number}\n    */\n    get r() {\n        return wasm.__wbg_get_rgb_r(this.ptr);\n    }\n    set r(arg0) {\n        return wasm.__wbg_set_rgb_r(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get g() {\n        return wasm.__wbg_get_rgb_g(this.ptr);\n    }\n    set g(arg0) {\n        return wasm.__wbg_set_rgb_g(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get b() {\n        return wasm.__wbg_get_rgb_b(this.ptr);\n    }\n    set b(arg0) {\n        return wasm.__wbg_set_rgb_b(this.ptr, arg0);\n    }\n    /**\n    * @param {number} r\n    * @param {number} g\n    * @param {number} b\n    * @returns {Rgb}\n    */\n    new(r, g, b) {\n        return Rgb.__wrap(wasm.rgb_new(this.ptr, r, g, b));\n    }\n}\n\nexport function __wbindgen_object_clone_ref(idx) {\n    return addHeapObject(getObject(idx));\n}\n\nexport function __wbindgen_object_drop_ref(i) { dropObject(i); }\n\n"],"sourceRoot":""}